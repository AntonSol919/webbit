<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf8" http-equiv="Content-Type" />

    <link rel="stylesheet" href="./linkspace-black-colorcodes.css">
    <link rel="stylesheet" href="./linkspace-basic-black.css">
    <style>

     html {
         color: 	#f8f8f2;
         box-sizing: border-box;
         font-size: calc(15px + 0.390625vw);
         background:#282a36;
     }


     body{
         display:flex;
         flex-flow:column;
         align-items: flex-start;
     }

     #form > div > label {
         display:inline-block;
         width: 14em;
     }

    </style>
</head>

<body>
    <h3 style="color:#ff5555;background:#f1fa8c;" id="warningHeader">
        before entering a password check that the host starts with the word 'quarantine' and that you trust this server
        <input id="hideWarningToggle" type="checkbox" /></div>
    </h3>
    <div id="form">
        <div>
            <label>Lk ID</label> <input type="button" id="generateKey" value="new"/><input id="encryptedKey" name="username" type="text">
        </div>
        <div> <label>Password</label> <input id="password" name="password" type="password"/></div>
        <div> <label> On Save </label></div>
        <div> <label> Store Password </label> <input id="rememberPass" type="checkbox" checked/></div>
        <div> <label> Back </label> <label id="backUrl" contentEditable="true"></label></div>
        <div> <label> Open full URL </label> <input id="useFullUrl" type="checkbox"/></div>
        <input id="submitEl" type="submit" value="Vouch" />
    </div>

</body>
<script type="module">
    import init, {
        lk_keygen,
        lk_key_encrypt,
        lk_key_decrypt,

        lk_datapoint,
        lk_linkpoint,
        lk_keypoint,

        lk_read,
        lk_write,

        lk_encode,

        b64,
        Link,
        get_consts,
        build_info
    } from './linkspace-dev/linkspace.js'; 
 // } from 'https://antonsol919.github.io/webbit/linkspace/linkspace.js';

    function stripSuffix(st, suffix) {
        if (!st.endsWith(suffix)) throw `${st} does not end with ${suffix}`;
        return st.substr(0, st.length - suffix.length);
    }

    function elIdObj(el, intoObj = {}) {
        let id = el.attributes.id;
        intoObj[id && id.value] = el;
        [...el.children].forEach((e) => elIdObj(e, intoObj));
        return intoObj;
    }

    const range = document.createRange();

    function newEl(el) {
        return range.createContextualFragment(el).firstElementChild;
    }
    const loc = window.location;
    const params = new URLSearchParams(loc.search);
    const linkp_hash = params.get('hash');
    const back = params.get('back');
    const quarantinePktsUrl = `${loc.origin}/blob?hash=${linkp_hash}`;
    const vouchUrl = `${loc.origin}/vouch?hash=${linkp_hash}`;

    async function load_pkts(response) {
        if (!response.ok) {
            let body = await response.text();
            return alert(`Error - ${response.status} - ${response.statusText} - ${body}`);
        }
        let blob = await response.blob();
        let buf = await blob.arrayBuffer();
        let bytes = new Uint8Array(buf);
        window.linkspace = await init();
        console.log(build_info());
        const {
            PUBLIC
        } = get_consts();

        let pkts = [];
        while (bytes.length != 0) {
            let [p, rest] = lk_read(bytes);
            bytes = rest;
            pkts.push(p);
        }
        if (b64(pkts[0].hash) != linkp_hash) {
            logerr("(NoSec) Error - hash in url does not match the first pkt ?");
        }
        return pkts;
    }

    let errors = newEl(`<div id="errors"></div>`);
    document.body.prepend(errors);

    function logerr(e) {
        errors.prepend(range.createContextualFragment(`<div>${e}</div>`).firstElementChild);
    }

    function display_pkts(pkts) {
        let linkpkt = pkts[0];
        let {
            warningHeader,
            hideWarningToggle,
            encryptedKey,
            password,
            generateKey,
            submitEl,
            rememberPass,
            useFullUrl,
            backUrl
        } = elIdObj(document.body);
        
        function hideWarning(){
            warningHeader.style.display = hideWarningToggle.checked ? "none" : "block";
            localStorage.setItem("hideWarning",hideWarningToggle.checked);
        }
        hideWarningToggle.addEventListener("change",hideWarning);
        hideWarningToggle.checked = localStorage.getItem("hideWarning") || false;
        hideWarning()
        encryptedKey.value= encryptedKey.value || localStorage.getItem("encrypted_key") || "";
        password.value= password.value || localStorage.getItem("password") || "";
        backUrl.innerText = back

        let displayKeyGen = () => {
            if (encryptedKey.value != "") {
                submitEl.style = "display:block";
                generateKey.style = "display:none";
            } else {
                generateKey.style = "display:block";
                submitEl.style = "display:none";
            }
        }
        displayKeyGen();
        encryptedKey.addEventListener("input", displayKeyGen);
        generateKey.addEventListener("click", async () => {
            if (encryptedKey.value != "" && !confirm("destroy key?")) {
                return false;
            }
            if (password.value == "") {
                password.value = prompt("password");
            }
            let bytes = new TextEncoder().encode(password.value);
            let tmp = generateKey.value;
            generateKey.value = "⏳";
            await new Promise(resolve => setTimeout(resolve, 100));
            encryptedKey.value = lk_key_encrypt(lk_keygen(), bytes);
            generateKey.value = tmp;
            displayKeyGen();
            return false;
        });

        submitEl.addEventListener("click", () => {
                try {
                    let key = lk_key_decrypt(encryptedKey.value, new TextEncoder().encode(password.value));
                    localStorage.setItem("encrypted_key", encryptedKey.value);
                    if (rememberPass.checked) {
                        localStorage.setItem("password", password.value)
                    };
                    let keyp = lk_keypoint(key, "", {
                        ...linkpkt.obj, // Get an object with the common fields
                        create: undefined // Don't copy the create stamp field
                    });
                    let new_hash = b64(keyp.hash);

                    let html = keyp.toHTML();
                    let formEl = document.querySelector("#form");
                    formEl.insertAdjacentHTML("afterend",keyp.toHTML());
                    let countdown = range.createContextualFragment(`<input type="range" min=1 max=1000 value=100>`).firstElementChild;
                    formEl.insertAdjacentElement("afterend",countdown);

                    var id = 0;
                    id = setInterval(() => {
                        countdown.value = Number(countdown.value) *1.01 + "";
                        if (countdown.value == countdown.max){
                            clearInterval(id);
                            send();
                    }},10);

                                        
                    async function send (){
                        const formData = new FormData();
                        fetch(vouchUrl, {
                            body: lk_write(keyp),
                            method: "POST"
                        }).then(async response => {
                            if (!response.ok) {
                                let body = await response.text();
                                throw Error(`Server returned ${response.status}: ${response.statusText} - ${body}`);
                            }
                            if (backUrl.innerText != "") {
                                window.location = backUrl.textValue;
                            }else {
                                // In theory we could use the location from our packet - but its a TODO to specify the exact path encoding rules
                                let loc = response.headers.get("location");
                                if (!useFullUrl.checked){
                                    loc =  loc.split("?")[0];
                                }
                                window.location = loc;
                            }
                        }).catch(logerr);
                    }
                        
                    } catch (e) {
                        logerr(e);
                    }
                return false;
            });

            for (let pkt of pkts) {
                let html = pkt.toHTML();
                let el = range.createContextualFragment(html).firstElementChild;
                document.body.appendChild(el);
            }
        }

        async function run() {
            init();
            const response = await fetch(quarantinePktsUrl)
                .then(load_pkts)
                .then(display_pkts);
        }
        run().catch((e) => console.error(e, e.toString && e.toString(), e.toJSON && e.toJSON()));
</script>

</html>
