<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf8" http-equiv="Content-Type" />
    <style>

     #form > div > label {
         display:inline-block;
         width: 14em;
     }

    </style>
</head>

<body>
    <h3 style="color:red;background:yellow"> before entering a password check that the origin host contains the word 'quarantine' and that you trust this server</h3>
    <div id="form">
        <div>
            <label>Lk ID</label> <input type="button" id="generateKey" value="new"/><input id="encryptedKey" name="username" type="text">
        </div>
        <div> <label>Password</label> <input id="password" name="password" type="password"/></div>
        <div> <label> On Save </label></div>
        <div> <label> Store Password </label> <input id="rememberPass" type="checkbox" checked/></div>
        <div> <label> Back </label> <label id="backUrl" contentEditable="true"></label></div>
        <div> <label> Open full URL </label> <input id="useFullUrl" type="checkbox"/></div>
        <input id="submitEl" type="submit" value="Vouch" />
    </div>

</body>
<script type="module">
    import init, {
        lk_keygen,
        lk_key_encrypt,
        lk_key_decrypt,

        lk_datapoint,
        lk_linkpoint,
        lk_keypoint,

        lk_read,
        lk_write,

        b64,
        Link,
        get_consts,
        build_info
    } from './linkspace/linkspace.js'; 
 // } from 'https://antonsol919.github.io/webbit/linkspace/linkspace.js';

     console.log(build_info());
    function stripSuffix(st, suffix) {
        if (!st.endsWith(suffix)) throw `${st} does not end with ${suffix}`;
        return st.substr(0, st.length - suffix.length);
    }

    function elIdObj(el, intoObj = {}) {
        let id = el.attributes.id;
        intoObj[id && id.value] = el;
        [...el.children].forEach((e) => elIdObj(e, intoObj));
        return intoObj;
    }

    const range = document.createRange();

    function newEl(el) {
        return range.createContextualFragment(el).firstElementChild;
    }
    const loc = window.location;
    const params = new URLSearchParams(loc.search);
    const linkp_hash = params.get('hash');
    const back = params.get('back');
    const quarantinePktsUrl = `${loc.origin}/blob?hash=${linkp_hash}`;
    const vouchUrl = `${loc.origin}/vouch?hash=${linkp_hash}`;

    async function load_pkts(response) {
        if (!response.ok) {
            let body = await response.text();
            return alert(`Error - ${response.status} - ${response.statusText} - ${body}`);
        }
        let blob = await response.blob();
        let buf = await blob.arrayBuffer();
        let bytes = new Uint8Array(buf);
        window.linkspace = await init();
        const {
            PUBLIC
        } = get_consts();

        console.log(PUBLIC);
        let pkts = [];
        while (bytes.length != 0) {
            let [p, rest] = lk_read(bytes);
            bytes = rest;
            pkts.push(p);
        }
        if (b64(pkts[0].hash) != linkp_hash) {
            throw Error("(NoSec) Error - hash mismatch - ?");
        }
        console.log(pkts);
        return pkts;
    }
    let errors = newEl(`<div id="errors"></div>`);
    document.body.prepend(errors);

    function logerr(e) {
        errors.prepend(range.createContextualFragment(`<div>${e}</div>`).firstElementChild);
    }

    function display_pkts(pkts) {
        let linkpkt = pkts[0];
        let {
            encryptedKey,
            password,
            generateKey,
            submitEl,
            rememberPass,
            useFullUrl,
            backUrl
        } = elIdObj(document.querySelector("#form"));
        encryptedKey.value= encryptedKey.value || localStorage.getItem("encrypted_key") || "";
        password.value= password.value || localStorage.getItem("password") || "";
        backUrl.innerText = back

        let displayKeyGen = () => {
            if (encryptedKey.value != "") {
                submitEl.style = "display:block";
                generateKey.style = "display:none";
            } else {
                generateKey.style = "display:block";
                submitEl.style = "display:none";
            }
        }
        displayKeyGen();
        encryptedKey.addEventListener("input", displayKeyGen);
        generateKey.addEventListener("click", async () => {
            if (encryptedKey.value != "" && !confirm("destroy key?")) {
                return false;
            }
            if (password.value == "") {
                password.value = prompt("password");
            }
            let bytes = new TextEncoder().encode(password.value);
            let tmp = generateKey.value;
            generateKey.value = "⏳";
            await new Promise(resolve => setTimeout(resolve, 100));
            encryptedKey.value = lk_key_encrypt(lk_keygen(), bytes);
            generateKey.value = tmp;
            displayKeyGen();
            return false;
        });

        submitEl.addEventListener("click", () => {
                try {
                    let key = lk_key_decrypt(encryptedKey.value, new TextEncoder().encode(password.value));
                    localStorage.setItem("encrypted_key", encryptedKey.value);
                    if (rememberPass.checked) {
                        localStorage.setItem("password", password.value)
                    };
                    let keyp = lk_keypoint(key, "", {
                        ...linkpkt.obj, // Get an object with the common fields
                        create: undefined // Don't copy the create stamp field
                    });
                    let new_hash = b64(keyp.hash);
                    let el = newEl("<pre></pre>");
                    el.textContent = keyp.toString();
                    document.body.prepend(el);
                    const formData = new FormData();
                    fetch(vouchUrl, {
                        body: lk_write(keyp),
                        method: "POST"
                    }).then(async response => {
                        if (!response.ok) {
                            let body = await response.text();
                            throw Error(`Server returned ${response.status}: ${response.statusText} - ${body}`);
                        }
                        if (backUrl.innerText != "") {
                            window.location = backUrl.textValue;
                        }else {
                            // In theory we could use the location from our packet - but its a TODO to specify the exact path encoding rules
                            let loc = response.headers.get("location");
                            if (!useFullUrl.checked){
                                loc =  loc.split("?")[0];
                            }
                            window.location = loc;
                        }
                    }).catch(logerr);

                } catch (e) {
                    logerr(e);
                }
                return false;
            });

            for (let pkt of pkts) {
                let el = newEl("<pre></pre>");
                el.textContent = pkt.toString();
                document.body.appendChild(el);
            }
        }

        async function run() {
            init();
            const response = await fetch(quarantinePktsUrl)
                .then(load_pkts)
                .then(display_pkts);
        }
        run().catch((e) => console.log(e, e.toString && e.toString(), e.toJSON && e.toJSON()));
</script>

</html>
